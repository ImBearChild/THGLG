---
title: "使用 shell"
---

# 使用 Shell

## 前言

在图形化界面普及之前，电脑操作人员都是在命令行界面（CLI）中使用命令和计算机进行交互。

在 Linux 中，用于解释，管理命令的程序被称之为 **shell**。shell 提供了一个创建可执行脚本文件、运行程序、与文件系统进行交互、编译源码和管理计算机系统的办法。虽然命令行界面不太直观，但 shell 可以简单明了地配置许多并不存在于图形化界面中的设置参数，许多 Linux 专家认为命令行的效率高于图形化界面。

本文所描述的内容都是基于 **bash shell**，有关其他 shell 的使用方法请自行查阅资料。

## 关于 shell 与终端窗口

Linux 上访问 shell 界面的方法有很多，其中最常见的三种办法是：shell 提示符、终端窗口、虚拟控制台。

### 使用 shell 提示符

如果你安装的系统没有安装图形化界面，你登录系统后就会看到类似于：

```
Red Hat Enterprise Linux Server release 8.0 (Ootpa)
Kernel 4.18.0-42.el8.x86_64 on an X86
mylinuxhost login:
```

在此，你可以使用你的用户名和密码登录系统。

shell 的 `$` 提示符号表示当前为普通用户登录，`#` 提示符号表示当然前为 root 用户登录。

```
$ cp ~/Downloads/Tela-dark ~   #不需要管理员权限
# cp ~/Downloads/Tela-dark /usr/share/icons  #需要管理员权限
```

以上例子是将用户目录的下载文件（`~/Downloads`）内的 `Tela-dark` 的文件夹复制到两个地方，一个是用户目录（`~`），一个是共享文件夹（`/usr/share/icons`）。在命令的末尾，由 `#` 加文字组成的字符串是注释，注释不会被执行，但是有益于向读者解释当前命令或源码的含义。

### 使用虚拟控制台

大多数带有桌面环境的 Linux 发行版会在运行过程中启用多个虚拟控制台（virtual consoles），虚拟控制台是一个同时使用多个 shell 会话的办法。

你可以使用 `Ctrl` + `Alt` + `F1`~`F6` 快捷键组合在多个虚拟控制台间切换。要回到图形化界面，你只需要按下 `Ctrl` + `Alt` + `F1` 即可，一般而言，GUI 会在第一或第二个虚拟控制台运行，其他的虚拟控制台通常是命令行界面。

在切换到其他虚拟控制台后，你可以输入用户名和密码登录 shell，或者键入 `exit` 退出 shell 会话。

### 使用终端

一般而言，Linux 桌面都会有自己的终端模拟器。打开桌面环境自带的终端应用程序（它一般叫“终端”或者“Terminal”），你就能直接看到一个命令行界面（CLI）提示符，例如：

```
[bh@c004-v1 ~]$
```

`bh` 是 Linux 用户的用户名，`c004-v1` 是 Linux 用户的主机名，`~` 表示 Linux 用户当前所在的文件夹是用户目录，即 `/home/bh`。不同的终端程序的样式会略有不同，但基本格式是一样的。要退出终端，你只需要关闭窗口或者键入 `exit` 即可。

- 注意，直接关闭终端窗口会导致该窗口运行的程序或命令终止。

要在终端中运行命令，只需要在提示符后输入命令，然后按下 `Enter` 键即可，如：

```
[bh@c004-v1 ~]$ date
2022年 01月 17日 星期一 17:14:31 CST
[bh@c004-v1 A1]$ echo Hello World!
Hello World!
```

`date` 命令可以用于显示当前的系统时间，日期和时区（输出内容的格式与你设置的语言和地区有关系）。相同命令还有 `uptime`，用于查看系统的开机时间。`echo` 命令可以将你输入的内容打印在屏幕上。

```
[bh@c004-v1 ~]$ uptime
 17:16:26 up 9 min,  1 user,  load average: 0.05, 0.12, 0.11
```

如上，系统于 `17:16:26` 开机，已开机 9 分钟，共有一个已登录用户（`bh`），1 分钟，5 分钟和 15 分钟内的系统平均负载分别是 0.05、0.12 和 0.11。

系统负载（System Load）是系统 CPU 繁忙程度的度量，即有多少进程在等待被 CPU 调度（进程等待队列的长度）。平均负载（Load Average）是一段时间内系统的平均负载，这个一段时间一般取 1 分钟、5 分钟、15 分钟。

假设你的 CPU 是单核，它在单位时间内的事件处理能力有限的，当它被待处理事件填满，满负载运作的时候，load = 1；小于表示 CPU 未满载，大于 1 则表示超载工作，此时 CPU 不仅需要处理当前事务，还有更多的事务正在排队等待处理。如果你有一个四核 CPU，则当 load = 4 时，表示你的四个 CPU 核心均在满负载工作。对于单核 CPU，当 load 超过 1 时，你应该检查一下什么东西占用了大量的 CPU 资源，以此类推。

此外还有几个命令值得一试：

```
[bh@c004-v1 ~]$ pwd
/home/bh
[bh@c004-v1 ~]$ hostname
c004-v1
[bh@c004-v1 ~]$ ls
公共  模板  视频  图片  文档  下载  音乐  桌面  Applications
```

`pwd` 即，print working directory（打印你当前所在的文件夹至输出结果），`hostname` 用于显示你的主机名，`ls` 用于显示你所在文件夹的所有文件。

## 运行命令

### 命令的语法

大多数命令都有一个或多个选项（option），你可以通过添加选项来改变命令的执行方式。

选项通常由一个前面带有连字符（`-`）的单个字母组成。你可以将单个字母选项组合在一起，或者在每个选项前面加上连字符以使用多个一次一个选项。例如下面两个使用 ls 命令的选项，效果是相同的：

```
$ ls -l -a -t
$ ls -lat
```

如上，你使用了 `-l`（长列表）、`-a`（显示包括隐藏文件在内的全部文件和文件夹）、`-t`（按时间排序） 修改了 `ls` 的运行模式。`ls` 命令用于显示当前目录的所有常规文件（默认不显示隐藏内容，即以 `.` 开头的文件或文件夹）。

一些命令的选项可能会使用单个单词来表示，要使用这些选项，你需要使用两个连字符（`--`），如 `--help`。如果没有这么做，系统尝试将这个单词理解成多个选项缩写字母组合在一起的选项。你可以将 `--help` 附加在绝大多数命令的后面，来获取有关该命令定义的选项和参数（argument）信息，例如：`uptime --help`。

许多命令会使用参数（argument），这些参数通常紧跟在选项的后面或者整个命令的末尾。参数本质是一条额外的信息，它可能是文件名、目录、用户名、设备或者其他东西，用于告知系统应该执行什么操作。例如：`cat /etc/hosts` 会将 `/etc/hosts` 中包含的信息打印在你的屏幕上，`/etc/hosts` 就是一个参数。你可以在命令行中输入很多个参数（数量取决于单行的字符数量限制）。

有时候，参数也会和选项联系在一起，此时，参数必须紧跟在选项的后面。如果选项是单个字母，请使用空格将参数与选项分割开，如果选项是一个单词，请使用等号将其连接起来，例如：

```
[bh@c004-v1 ~]$ ls --hide=FolderA
公共  模板  视频  图片  文档  下载  音乐  桌面  Applications
[bh@c004-v1 ~]$ ls
公共  模板  视频  图片  文档  下载  音乐  桌面  Applications  FolderA
```

如上，`--hide` 选项让 `ls` 在读取紧随其后的参数后，从输入结果中隐藏了 FolderA 文件夹。请注意，选项和参数用等号连接起来，中间不要有空格。

```
$ tar -cvf test.tar FolderA
```

如上，这是一个单字母选项用空格连接一个参数的例子。这条命令表示使用 `tar` 命令创建（`c`）一个名为 `test.tar` 的文件（`f`），并在创建备份时显示详细 (verbose，`v`) 消息；该文件包含 FolderA 文件夹中的所有子文件夹和文件（该命令还使用了相对路径，有关于此，将在后文详述）。因为 `test.tar` 是 `-f` 选项的参数，所以 `test.tar` 必须紧随其后（用空格隔开）。

你还可以使用 `uname` 查看系统版本，加上 `-a` 还可以查看内核版本，主机名，uptime 等信息，如下：

```
[bh@c004-v1 ~]$ uname -a
Linux c004-v1 5.15.14-200.fc35.x86_64 #1 SMP Tue Jan 11 16:49:27 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
```

`id` 可用于查看你的用户名，加入的用户组，`who` 可以用于查阅你的用户名，登录的终端和时间，类似的还有 `whoami`。如下：

```
[bh@c004-v1 ~]$ who
bh       tty1         2022-01-17 17:06 (:0)
[bh@c004-v1 ~]$ id
用户id=1000(bh) 组id=1000(bh) 组=1000(bh),10(wheel) 上下文=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

如上，当你登录 Linux 的时候，Linux 会使用一系列的信息（用户名，组名，ID 等）识别你，跟踪你的活动。在此例中，数字化的用户 ID（UID）是 1000，用户 `bh` 所在的主要用户组是 `bh`，其组 ID（gid）是 1000。`bh` 还是 `wheel` 组（gid=10）的成员（即系统管理员）。

- 一般而言，用户所在的组应该是 `users`，但 Fedora 和 RHEL 及其衍生发行版都是采用 [User Private Groups](https://web.mit.edu/rhel-doc/3/rhel-rg-en-3/s1-users-groups-private-groups.html)，所以用户名通常和用户首要组相同。

当你输入一堆的命令后，你可以使用 `clear` 清空整个屏幕

### 定位命令的位置

你在 Linux 上所输入的命令一般都存储在你的路径（path）中，对于不在路径中的命令，你可以输入命令位置的完整标识。

为了方便起见，建议将你自己创建或使用的自定义命令放置到路径中，然后将这些目录添加到 shell 的 `PATH` 环境变量中。该路径由一系列目录组成，这些目录会按顺序检查你输入的命令。要查看这些目录，请运行：

```
[bh@c004-v1 ~]$ echo $PATH
/home/bh/.local/bin:/home/bh/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin
```

以上显示了一个 Linux 用户默认的路径位置，位于路径中的文件夹用 `:` 分隔开来。大多数用户命令都存储在 `/bin`、`/usr/bin` 和 `/usr/local/bin` 目录中，`usr/local/sbin` 和 `/usr/sbin` 目录储存管理员命令（一些 Linux 系统不会把这些东西放在普通用户的目录中）。最开始的两个目录（`~/.local/bin` 和 `~/bin`）是位于用户目录中的文件夹。

Linux 不像其他系统（如 Windows）会在执行命令前会先检查当前目录是否含有可执行文件或命令，而是先检查 `PATH` 变量所包含的文件夹。要执行当前文件夹的命令，你必须指定他们的绝对路径，如运行 `$ ./home/bh/Applications/Mount.sh` 执行一个用户存放于 `~/Applications` 的自定义 shell 脚本。

`PATH` 变量中，文件夹的排序是很重要的。系统会从左往右逐个检查 `PATH` 中包含文件夹，如果你有两个相同名称但存储于不同目录的文件，那么系统会先执行首先检索到的命令，如果要执行另一个命令，你需要指定该命令所在的完整目录地址，或者修改 `PATH` 变量（后续将详述）。

除了存储在 `PATH` 变量中的文件夹的命令，一些命令内置在 shell 中。可以通过创建定义你希望该命令运行的任何命令和选项的别名来覆盖其他命令。还有一些方法可以定义由一系列存储的命令组成的函数。系统一般以以下顺序检查你输入的命令：

1. **Aliases**（别名），这些是由 `alias` 命令设置的名称，代表特定的命令和一组选项。你可以使用 `alias` 为长而复杂的命令定义一个短名称，相关内容将在后续详述。
2. **Shell reserved word**（shell 保留字词），其中许多是你将在编程类型函数中使用的词，例如 `do`、`while`、`case` 和 `else`。
3. **Function**（函数），这是一组在当前 shell 中一起执行的命令。
4. **Built-in command**（内置命令），这是一些内置于 shell 中的命令，例如 `cd`（更改目录）、`echo`（将文本输出到屏幕）、`exit`（退出 shell）等。
5. **Filesystem command**（文件系统命令），该命令存储在计算机的文件系统中并从其执行。（这些是由 PATH 变量的值指示的命令。）

你可以使用 `type` 命令确定某个命令的位置，如

```
[bh@c004-v1 ~]$ type cd
cd 是 shell 内建
[bh@c004-v1 ~]$ type dnf
dnf 是 /usr/bin/dnf
```

如果一个命令同时存储于多个文件夹，你可以使用 `-a` 选项列出这些目录，如 `$ type -a ls`,列举出 `ls` 的全部位置和别名。

如果你遇到命令不存在或访问被拒绝的情况，如果命令不存在，请检查你的命令是否拼写正确以及它是否位于 `PATH` 变量的目录中，或你是否安装了包含该命令的软件包；如果访问被拒绝，请检查你是否有相应的权限执行该命令。

如果某个目录不存在于你的 `PATH` 变量中，你可以使用 `locate` 查询整个系统所有的文件夹（你可以访问的部分），要查找某些文件夹（如 `/root/bin`），你需要 `root` 权限。

## 查询命令使用历史

人是有极限的，记不住太多的东西。所以你需要知道如何查询你之前干了什么，以及那一串长长的字母究竟是怎么打才能正确运行。

你可以使用 `history` 查询你最近输过的命令。然后用鼠标选中复制，然后使用 `Ctrl` + `Shift` + `V` 快捷键组合将内容复制到终端中。或者你可以使用方向键 `↑` 和 `↓` 显示你之前输过的命令。然后使用 `←` 和 `→` 移动光标，编辑命令。

### 命令行编辑

bash shell 支持基于 [emacs](https://www.gnu.org/software/emacs/) 文本编辑器的命令行编辑功能（你可以输入 `man emacs` 查阅相关用户手册了解更多信息，要关闭手册按，只需要按 `q` 即可退出）来编辑你输入的命令。

### 命令行补全

bash shell 提供了几种不同的方法来补全部分键入的值。要尝试完成一个值，请键入前几个字符并按 `Tab` 键。以下是你可以从 bash shell 中部分键入的一些值：

- **命令，别名或函数**  如果你键入的文本以常规字符开头，shell 会尝试使用命令、别名或函数名来完成文本。
- **变量**  如果你键入的文本以 `$` 开头，shell 补齐变量。
- **用户名**  如果你键入的文本以 `~` 开头，shell 会使用用户名（username）补齐文本。例如 `cd ~`，移动到当前用户的家目录。
- **主机名**  如果你键入的文本以 `@` 开头，shell 会使用 `/etc/hosts` 文件中的主机名补齐文本。

```
[bh@c004-v1 ~]$ echo $P<Tab>
$PANEL_GDK_CORE_DEVICE_EVENTS  $PROMPT_COMMAND                $PS4
$PATH                          $PS0                           $PWD
$PIPESTATUS                    $PS1                           
$PPID                          $PS2  
[bh@c004-v1 ~]$ echo $P
```

如上，输入 `echo $P` 再按下 `Tab` 键，shell 会显示以 `$P` 开头的变量。在显示变量后，shell 会回到原本的位置 `echo $P`，你可以继续输入命令。

还有其他几个命令你可以试试看：

```
$ echo $OS<Tab>
$ cd ~ro<Tab>
$ userm<Tab>
```

### 命令行召回

你所输入的命令都会存储在 shell 的历史记录列表中，当你退出 shell 会话后，这些记录会存储到一个 history 文件中，以便下一次会话时查阅。

你可以使用 `history` + 数字显示你所希望看到的历史命令的数量，使用方向键 `↑` 和 `↓` 上下翻页，如：

```
[bh@c004-v1 ~]$ history 10
  326  cd ~
  327  ls
  328  sudo dnf up -y
  329  uptime
  330  id
  331  whoami
  332  type locate
  333  type ls
  334  cat /etc/hosts
  335  history 10
[bh@c004-v1 ~]$ !329
uptime
 11:06:42 up  2:04,  1 user,  load average: 0.14, 0.17, 0.10
```

然后使用 `!` + 数字的形式执行之前运行过的命令。你可以使用 `Ctrl` + `S` 搜索命令，执行或编辑结果。

## 连接和扩展命令

shell 的一个强大功能就是将命令的输入输出重定向，以实现和其他文件或命令进行交互的目的。元字符（Metacharacters）是一种类型字符，对 shell 具有特殊意义，用于连接命令或请求扩展。

元字符包括竖线符号 (`|`)、和号 (`&`)、分号 (`;`)、右括号 (`)`)、左括号 (`(`)、小于号 (`<`) 和大于号 (`>`)。

### 命令之间的管道连接

竖线符号 (`|`) 用于将一个命令的输出连接到另一个命令的输入。这可以用于让一个命令处理某些数据，然后让下一个命令处理结果。例如：

```
$ cat /etc/passwd | sort | less
```

如上，使用 `cat` 读取 `/etc/passwd` 文件，然后将输出通过管道（`|`）传送到 `sort` 命令。`sort` 命令采用 `/etc/passwd` 文件每一行开头的用户名，按字母顺序对它们进行排序，然后将输出通过管道传递给 `less` 命令（以对输出进行分页）。通过类似这样的办法，可以让 Linux 同时执行多个互相协作的命令。

### 顺序命令

分号 (`;`) 可以让 shell 依次执行多个命令，但与 `|` 的不同之处在于，`;` 并没有传递命令输入输出的能力。如下：

```
[bh@c004-v1 ~]$ touch test; chmod +x test; ls -ld test; date
-rwxrwxr-x. 1 bh bh 0  1月 20 08:42 test
2022年 01月 20日 星期四 08:42:49 CST
```

创建文件，修改文件权限以及查询文件属性的命令都通过 `;` 连接起来。

### 后台命令

某些命令可能需要一段时间才能完成。有时，你可能不想占用 shell 等待命令完成。 在这些情况下，你可以使用和号 (`&`) 让命令在后台运行，要让命令在后台运行，只需要在命令的末尾加上 `&` 即可，例如：`$ sudo dnf up -y &`（在后台更新系统）。

注意，在进程完成之前请勿关闭终端窗口，这会直接杀死进程。

### 扩展命令

通过命令替换，你可以让 shell 解释命令的输出，而不是命令本身。这样，你可以让命令的标准输出成为另一个命令的参数。进行命令替换有两种办法：使用 $(command) 或者使用反引号（`）包围命令。如下：

```
$ touch test.sh; nano $(find ~ | grep test)
$ touch test.sh; nano `find ~ | grep test`
```

如上，该命令首先在用户的主目录（`~`）中创建一个 test.sh 文本文件。然后 shell 会先执行 `$()` 括号内的内容或反引号包围的内容。也就是 `find` 会将用户目录中的所有文件名打印出来，然后导入 `grep` 命令。`grep` 会筛选出所有包含 “test” 关键字的文件，然后再用 `nano` 打开（Nano 会依次打开这些文件，要关闭这些窗口，请使用 Ctrl + X 快捷键）。

注意，此类命令在你只知道文件名而不知道文件路径的情况下很有实用价值。但使用的时候请尽量确定文件所处的大致范围，如果你直接在 `/` 下查询，你可能会一次性打开大量的文件。

### 扩展算术表达式

有时，你想将算术结果传递给命令。你可以使用两种形式来扩展算术表达式并将其传递给 shell：`$[expression]` 或 `$(expression)`。如下：

```
[bh@c004-v1 ~]$ echo "这台电脑已经有 $[2022-2018] 年的运行时长了，它的主目录有 $(ls ~ | wc -w) 个文件。"
这台电脑已经有 4 年的运行时长了，它的主目录有 10 个文件。
```

如上，shell 首先执行 `$[]` 和 `$()` 中的内容，然后将运算结果传递给 `echo` 命令。第二个扩展算术表达式中，首先 `ls ~` 打印的内容会传递到下一个命令， `wc -w` 命令会计算输入内容中找到的文件数，然后再将这个数字传递给 `echo`。

### 扩展变量

在 shell 中存储信息的变量可以使用美元符号 (`$`) 元字符进行扩展。在命令行上展开环境变量时，将打印变量的值而不是变量名本身，如下所示：

```
[bh@c004-v1 ~]$ ls -l $BASH
-rwxr-xr-x. 1 root root 1389936  7月 22 02:34 /usr/bin/bash
```

你可以使用前几节“命令行补全”提到的办法，查看全部的环境变量。

## 使用 Shell 变量

shell 存储着一些对用户的 shell 会话可能有用的信息，这些信息称之为变量（variables）。例如 `$HOME`，用于确认你的用户目录路径。

你可以通过键入 `set` 命令查看为当前 shell 设置的所有变量。本地变量（local variables）的一个子集称为环境变量（environment variables）。环境变量是导出到从当前 shell 打开的任何新 shell 的变量。你可以输入 `env` 查看全部的环境变量。

你可以键入 `$ echo $VALUE` 查看特定的环境变量，其中 `VALUE` 将替换为该环境变量的名称。由于在 Linux 中总是有多种方法可以做任何事情，因此你还可以键入 `declare` 来获取当前环境变量及其值的列表以及 shell 函数列表。

除了你自己设置的那些之外，系统文件还设置了存储诸如配置文件位置、邮箱和路径目录等内容的变量。它们还可以存储你的 shell 提示符、历史列表的大小和操作系统类型的值。你可以通过在其前面加上美元符号 (`$`) 并将其放置在命令行的任何位置来引用任何这些变量的值。例如：

```
[bh@c004-v1 ~]$ echo $USER
bh
```

当你开启一个新的 shell 会话时，会有许多预先设置好的 shell 变量。

### 创建和使用别名

你可以使用 `alias` 命令有效地为以后要运行的任何命令和选项创建快捷方式。你可以使用 `alias` 命令添加和列出别名。例如：

```
$ alias p='pwd; ls -CF'
$ alias rm='rm -i'
```

如上，第一个示例中，将字母 p 作为运行命令 `pwd`，然后运行 `ls -CF` 以打印当前工作目录并以列的形式列出其内容的组合命令的别名。

第二个示例在你每次键入 `rm` 时运行带有 `-i` 选项的 `rm` 命令（这是通常为 root 用户自动设置的别名。系统会提示你删除每个单独的文件，而不是仅删除文件。这可以防止你通过错误地键入诸如 `rm *` 之类的内容来自动删除目录中的所有文件。)。

当您在 shell 中时，您可以通过键入 alias 命令来检查设置了哪些别名。 如果要删除别名，请使用 `unalias`（请记住，如果在配置文件中设置了别名，则在你打开另一个 shell 时会再次自动设置别名。）。有关别名的更多信息，详见 `$ man alias`。

- 常用 shell 环境变量：

|变量|描述|
|---|---|
|BASH|这包含 bash 命令的完整路径名。通常是 `/bin/bash`。|
|BASH_VERSION|这是一个代表当前 bash 命令版本的数字|
|EUID|这是当前用户的有效用户 ID 数字。它是在 shell 启动时根据 `/etc/passwd` 文件中的用户条目分配的|
|FCEDIT|如果设置，此变量指示 `fc` 命令用于编辑历史命令的文本编辑器。如果未设置此变量，则使用 `vi` 命令。|
|HISTFILE|这是你的历史文件的位置。它通常位于 `$HOME/.bash_history`。|
|HISTCMD|这将返回历史列表中当前命令的编号。|
|HOME|这是你的主目录。每次登录或键入带有任何选项的 `cd` 命令时，它都是你当前的工作目录。|
|HOSTTYPE|这是一个描述 Linux 系统运行的计算机体系结构的值。对于与 Intel 兼容的 PC，该值为 `i386`、`i486`、`i586`、`i686` 或类似 `i386-linux` 的东西。 对于 AMD 64 位机器，该值为 `x86_64`。|
|MAIL|这是你的邮箱文件的位置。该文件通常是你在 `/var/spool/mail` 目录中的用户名|
|OLDPWD|这是你更改到当前工作目录之前的工作目录。|
|OSTYPE|此名称标识当前操作系统。对于 Fedora Linux，OSTYPE 值是 `linux` 或 `linux-gnu`，具体取决于你使用的 shell 类型。（Bash 也可以在其他操作系统上运行。）|
|PATH|这是用于查找你键入的命令的以冒号分隔的目录列表。普通用户的默认值因不同的发行版而异，但通常包括以下内容：`~/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin`。对于不在 PATH 中命令，你需要键入要运行的命令完整的绝对路径或相对路径。|
|PPID|这是启动当前 shell 的命令的进程 ID（例如，包含 shell 的终端窗口）|
|PROMPT_COMMAND|这可以设置为每次显示 shell 提示符之前运行的命令名称。设置 `PROMPT_COMMAND=date` 会列出提示符出现之前的当前日期/时间。|
|PS1|这将设置你的 shell 提示符的值。你可以将许多项目读入提示符（日期、时间、用户名、主机名等）。有时命令需要额外的提示符，你可以使用变量 `PS2`、`PS3` 等进行设置|
|PWD|这是分配为当前目录的目录。每次使用 cd 命令更改目录时都会更改这个值。|
|RANDOM|访问此变量会导致生成一个随机数。数字在 0 到 9999 之间|
|SECONDS|这是自 shell 启动以来的秒数。|
|SHLVL|这是与当前 shell 会话关联的 shell 级别数。当你登录到 shell 时，SHLVL 为 1。每次你启动一个新的 bash 命令（例如，通过使用 su 成为新用户，或者通过简单地键入 bash），这个数字都会增加。|
|TMOUT|这可以设置为一个数字，表示 shell 可以在没有接收输入的情况下空闲的秒数。 达到秒数后，shell 退出。此安全功能降低了未经授权的人员访问无人看管的 shell 的可能性。（这必须在登录 shell 中设置，它实际上会导致 shell 注销用户。）|

要退出当前的 shell 会话，输入 `exit` 即可。

## 创建你自己的 shell 环境

你可以调整 shell 以使其更高效地工作。

### 配置 shell

shell 的行为由数个配置文件进行控制，一些配置会应用到每个用户和每个 shell 会话。其他一些配置只会对特定的用户生效。

- Bash 配置文件：

|文件名|描述|
|---|---|
|`/etc/profile`|该文件用于为每个用户设置用户环境信息。它在你第一次登录时执行。除了为您的邮箱位置和历史文件大小等设置环境变量外，该文件还为你的路径提供变量。最后，`/etc/profile` 会从 `/etc/profile.d` 目录中的配置文件中收集 shell 设置。|
|`/etc/bashrc`|该文件在每个运行 bash shell 的用户，每次打开 bash shell 时都会运行。它设置默认提示符并可能添加一个或多个命令别名。此文件中的值可以被每个用户的 `~/.bashrc` 文件中的信息覆盖。|
|`~/.bash_profile`|这是每个用户用来设置仅限于该用户的 shell 配置信息的文件。它只在当用户登录时执行一次。默认情况下，它会设置一些环境变量并执行用户的 `.bashrc` 文件。这是添加环境变量的好地方，因为一旦设置，它们就会被未来的 shell 会话继承。|
|`~/.bashrc`|这文件包含专用于你的 bash shell 的信息。登录系统时以及每次打开新的 bash shell 时 shell 都会读取它。这是添加别名的最佳位置，以便你的 shell 使用它们。|
|`~/.bash_logout`|它在你每次登出系统的时候执行（退出最后的 bash shell）。|

要更改 `/etc/profile` 或者 `/etc/bashrc` 文件，你需要 root 权限。但在 `/etc/profile.d/` 文件夹下创建自定义配置文件（如：setting.sh）是一个既能将变更应用整个系统又相对安全的办法，这避免了你直接损坏系统配置文件的糟糕情况。普通用户可以更改 `$HOME/.bash_profile`、`$HOME/.bashrc` 和 `$HOME/.bash_logout` 来为自己设置 shell 自定义配置。你可以使用 `nano` 编辑文件（如果担心操作失误，可以提前备份一下文件再编辑。），如：

```
$ nano $HOME/.bashrc
```

### 设置提示符

一般地，系统默认的 shell 提示符只包含基本的信息：你的用户名、主机名和当前所在的目录，一个 `#` 或者 `$` 符号，如下：

```
[bh@c004-v1 ~]$
```

要修改提示符的样式，你可以编辑 `PS2`、`PS3` 或 `PS4` 环境变量。你可以使用几个特殊字符（通过向各种字母添加反斜杠来表示）在提示符中包含不同的信息。特殊字符可用于输出你的终端编号、日期和时间以及其他信息。

- 向 Bash 提示添加信息的字符

|特殊字符|描述|
|---|---|
|`\!`|这显示了当前的命令历史编号。这包括为你的用户名存储的所有先前命令|
|`\#`|这显示了当前命令的命令号。这仅包括活动 shell 的命令|
|`\$`|这将显示用户提示符 ($) 或根提示符 (#)，具体取决于您的用户类型。|
|`\W`|这仅显示当前工作目录的基本名称。 例如，如果当前工作目录是 `/var/spool/mail`，则该值仅显示为 `mail`。|
|`\[`|这在非打印字符的序列之前。这可以用来在提示中添加终端控制序列，如改变颜色、添加闪烁效果或使字符变粗。(你的终端决定了可用的确切序列)。|
|`\]`|这跟随一系列非打印字符。|
|`\\`|这显示了一个反斜杠。|
|`\d`|这将显示当前日期的日期名称、月份和日期编号。|
|`\h`|这显示了运行 shell 的计算机的主机名。|
|`\n`|这会导致出现换行符。|
|`\nnn`|这显示了与替换 nnn 的八进制数相关的字符。|
|`\s`|这将显示当前的 shell 名称。对于 bash shell，值为 `bash`。|
|`\t`|这会以小时、分钟和秒为单位打印当前时间，例如 10:14:39。|
|`\u`|这将打印你当前的用户名。|
|`\w`|这将显示当前工作目录的完整路径。|

有关变更你的 bash shell 提示符的更多内容详见 [Bash Prompt HOWTO](https://tldp.org/HOWTO/Bash-Prompt-HOWTO/)。

### 添加环境变量

你可能需要添加一些自定义的环境变量到你的 `~/.bashrc` 文件。以下可以帮助你更好地使用 shell：

- **TMOUT**<br />这个环境变量设置了在 bash 自动退出之前 shell 可以处于非活动状态的时间。该值是 shell 未收到输入的秒数。这可能是一个很好的安全功能，以防你在仍登录 Linux 时离开办公桌。为防止在工作时被注销，你可能需要将该值设置为 TMOUT=1800 之类的值（以允许 30 分钟的空闲时间）。你可以使任何终端会话在设定的秒数后关闭当前 shell，例如，TMOUT=30。
- **PATH**<br />如前所述，PATH 变量设置搜索你使用的命令的目录。如果你经常使用不在路径中的命令目录，则可以永久添加这些目录。为此，请将 PATH 变量添加到你的 `~/.bashrc` 文件中。例如，要添加一个名为 `/getstuff/bin` 的目录，请添加以下内容：<br />
  ```
  PATH=$PATH:/getstuff/bin ; export PATH
  ```
  此示例首先将所有当前路径目录读入新的 PATH ($PATH)，添加 `/getstuff/bin` 目录，然后导出新的 PATH。
- **WHATEVER**<br />你可以创建自己的环境变量来为你的工作提供快捷方式。选择任何未使用的名称并为其分配有效值。例如，如果你对 /work/time/files/info/memos 目录中的文件进行大量工作，则可以设置以下变量
  ```
  M=/work/time/files/info/memos ; export M
  ```
  你可以通过键入 `cd $M` 将其设为当前目录。你可以通过键入 `$M/hotdog` 从该目录运行一个名为 hotdog 的程序。 您可以通过键入 `vi $M/bun` 从那里编辑一个名为 bun 的文件。

## 获取命令的信息

当你第一次启动 shell 的时候，孤零零的一个提示符可能会使你不知所措。以下是几种帮你熟悉 shell 的办法。

1. 检查路径。

键入 `$ echo $PATH`。你就会看见一系列包含你可以使用的命令的目录。然后再使用 `ls` 列出其中一个文件夹的文件，你就能看到这些命令的名字。

2. 使用 `help` 命令

有些命令内置于 shell，你并不能直接看见这些命令的可执行文件。你可以使用 `$ help | less` 列举出这些命令及其简单用法。

3. 使用 `--help` 选项

在你不熟悉的命令后面加上 `--help` 并不带其他参数或选项，就能打开此命令的帮助页面。例如，运行 `$ date --help | less`，你就能使用上下方向键翻页阅读帮助文档。有些命令则会使缩写字母作为帮助选项，如 `$ cfdisk -h`。

4. 使用 `info` 命令

`info` 命令是另一个用于显示来自 shell 的命令信息的工具。`info` 命令可以在节点层次结构中移动以查找有关命令和其他项目的信息。并非所有命令在 `info` 数据库中都有可用的信息，但有时可以在那里找到比手册页上更多的信息。

5. 使用 `man` 命令

你可以使用 `man` 命令直接查看命令附带的用户文档，如 `$ man hostnamectl`

使用 `man` 查看命令自带的用户手册是最为常见的一个获取信息的办法，一个完整的用户手册由以下部分组成：

|区域编号|区域名称|描述|
|---|---|---|
|1|用户命令<br />*User Commands*|普通用户能在 shell 内运行的命令（通常不需要管理员权限）。|
|2|系统调用<br />*System Calls*|应用程序中用于调用内核的编程函数。|
|3|C 函数库<br />*C Library Functions*|为特定编程库提供接口的编程函数（例如某些图形界面或在用户空间中运行的其他库的那些东西）。|
|4|设备和特殊文件<br />*Devices and Special Files*|代表硬件设备（如终端或 CD 驱动器）或软件设备（如随机数生成器）的文件系统节点。|
|5|文件格式和约定<br />*File Formats and Conventions*|文件类型（例如图形或文字处理文件）或特定配置文件（例如 passwd 或组文件）。|
|6|游戏<br />*Games*|系统内可用的游戏。|
|7|杂项<br />*Miscellaneous*|协议、文件系统、字符集标准等主题的概述。|
|8|系统管理工具和守护进程<br />*System Administration Tools and Daemons*|需要 root 或其他管理权限才能使用的命令。|

